
# Backend Architecture Plan: Autonomous Trading Engine

This document outlines the architecture for the backend Cloud Functions that will power the autonomous paper trading, analysis, and automation features of Cogmora Labs. The goal is to create a 24/7, server-side system that operates independently of the user's client application.

---

## 1. Core Goal

To transform the paper trading engine from a client-dependent tool into a fully autonomous, persistent service. This service will run scheduled tasks (AI analysis, watchlist scraping) and manage trade lifecycles (executing triggers, closing positions) even when the user is offline.

---

## 2. Key Components & Data Flow

-   **Firestore Database**: Serves as the "single source of truth." All state, including user settings, open positions, and active triggers, is stored here. The frontend UI and the backend functions both read from and write to Firestore.
-   **Cloud Functions for Firebase**: Provides the serverless compute environment where our backend logic will execute. We will use two primary types of functions:
    1.  **Scheduled Functions (Pub/Sub)**: Triggered on a recurring schedule (e.g., every minute) by Cloud Scheduler. These are perfect for our AI agent and watchlist scraper.
    2.  **Firestore Triggers (`onWrite`)**: Triggered automatically in response to specific data changes in the database. This is ideal for handling real-time events like closing a position.

### General Data Flow:
1.  **User (Frontend)**: Sets a schedule or configuration (e.g., "Run AI every 15 minutes") in the UI. This intent is written to their user profile in Firestore.
2.  **Cloud Scheduler**: On its defined interval (e.g., every minute), it triggers our main scheduled Cloud Function.
3.  **Scheduled Cloud Function (Backend)**:
    -   Wakes up and queries the `users` collection in Firestore.
    -   Finds all users whose scheduled tasks are due to run.
    -   Executes the required logic (e.g., runs the Genkit AI flow, scrapes KuCoin data).
    -   Writes the results (new triggers, updated watchlist) back to Firestore.
    -   Updates the `nextRun` timestamp in the user's profile for the next cycle.
4.  **User (Frontend)**: The `onSnapshot` listeners in the user's app see the new data in Firestore and the UI updates in real-time, displaying the new triggers or watchlist items generated by the backend.

---

## 3. Function Implementation Plan

### Function 1: Main Scheduler (`mainScheduler`)

This will be a single, efficient scheduled function that runs every minute and acts as an orchestrator for all user-specific tasks.

-   **Trigger**: Pub/Sub, via Cloud Scheduler (`every 1 minutes`).
-   **Logic**:
    1.  Get the current timestamp.
    2.  **Query for AI Agent Tasks**: Query all `users` documents where `aiSettings.scheduleInterval` is not null AND `aiSettings.nextRun` is less than or equal to the current time.
    3.  **Execute AI Tasks**: For each user found, asynchronously:
        -   Fetch their full context (watchlist, triggers, positions, etc.).
        -   Invoke the `proposeTradeTriggers` Genkit flow.
        -   If `aiSettings.autoExecute` is true, apply the returned plan to the user's Firestore documents (create/update/cancel triggers).
        -   Update the user's `aiSettings.nextRun` timestamp to `now + scheduleInterval`.
    4.  **Query for Watchlist Scraper Tasks**: Query all `users` documents where `automationConfig.updateMode` is `auto-refresh` AND `automationConfig.lastRun + automationConfig.refreshInterval` is less than or equal to the current time.
    5.  **Execute Scraper Tasks**: For each user found, asynchronously:
        -   Perform the screener scraping logic (same as in the current `applyWatchlistAutomation` function).
        -   Update the user's `watchlist` subcollection.
        -   Update the user's `automationConfig.lastRun` to the current time.

### Function 2: Position Closer (`closePositionHandler`)

This function will handle the financial calculations for closing a trade, ensuring atomicity and preventing the client from having to perform sensitive logic.

-   **Trigger**: Firestore `onWrite` on the path `/users/{userId}/paperTradingContext/main/openPositions/{positionId}`.
-   **Logic**:
    1.  The function inspects the change. If a position's `details.status` field was changed to `'closing'`.
    2.  It reads the full position data.
    3.  Calculates the final Profit & Loss (P&L):
        -   **Spot**: `(closePrice - entryPrice) * size`
        -   **Futures Long**: `(closePrice - entryPrice) * size`
        -   **Futures Short**: `(entryPrice - closePrice) * size`
    4.  It starts a Firestore transaction:
        -   Reads the user's main context document to get the current `balance`.
        -   Calculates the new balance: `currentBalance + pnl + collateral` (where collateral is returned for futures trades).
        -   Updates the user's `balance` in the main context document.
        -   Deletes the document from the `openPositions` collection.
        -   Updates the corresponding `tradeHistory` record with the final `pnl` and sets its status to `'closed'`.
    5.  The transaction ensures all these database updates succeed or fail together.

---

## 4. (Future Vision) Persistent WebSocket Worker

While scheduled functions are great for periodic tasks, a true real-time trigger system requires an always-on WebSocket connection. This is a more advanced setup.

-   **Architecture**: A dedicated, long-running service (e.g., a Node.js process on Cloud Run or a VPS) that maintains a single, persistent WebSocket connection to KuCoin for the `/market/ticker:all` topic.
-   **Logic**:
    1.  Receives a price tick.
    2.  Queries all `tradeTriggers` across all users in Firestore that match the incoming symbol.
    3.  For each matching trigger, it checks if the price condition is met.
    4.  If a condition is met, it writes to a new collection, e.g., `/pendingExecutions/{executionId}`, containing the `triggerId` and `userId`.
-   **Execution**: A separate `onWrite` Firestore trigger on `/pendingExecutions/{executionId}` would then wake up, execute the trade logic (similar to the `closePositionHandler`), and delete the trigger and pending execution documents.

This two-step process (persistent worker + Firestore trigger) creates a highly scalable and robust real-time system. We will focus on implementing Functions 1 and 2 first.

---

This plan provides a clear path to building the fully autonomous backend system. We can now proceed to write the code for the `mainScheduler` and `closePositionHandler` functions.
